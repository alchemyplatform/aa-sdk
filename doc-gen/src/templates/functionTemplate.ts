import dedent from "dedent";
import ts from "typescript";

const getSlug = (outputFilePath: string) => {
  const path = outputFilePath.split("/reference/")[1];

  return `wallets/reference/${path}`;
};

export const getFunctionName = (
  node: ts.VariableStatement | ts.FunctionDeclaration | ts.ClassElement,
  importedName: string,
) =>
  ts.isConstructorDeclaration(node)
    ? importedName
    : ts.isClassElement(node)
      ? (node.name?.getText() ?? importedName)
      : importedName;

export function extractCustomJSDocTag(
  node: ts.VariableStatement | ts.FunctionDeclaration | ts.ClassElement,
  tagName: string,
): string | null {
  const jsDocCommentAndTags = ts.getJSDocCommentsAndTags(node);
  if (!jsDocCommentAndTags.length) return null;

  const comment = jsDocCommentAndTags.find(
    (x) => x.kind === ts.SyntaxKind.JSDoc,
  ) as ts.JSDoc;

  if (!comment.tags) return null;

  const customTag = comment.tags.find(
    (x) =>
      x.kind === ts.SyntaxKind.JSDocTag && x.tagName.escapedText === tagName,
  );

  if (!customTag) return null;

  return ts.getTextOfJSDocComment(customTag.comment) || null;
}

export function functionTemplate(
  node: ts.VariableStatement | ts.FunctionDeclaration | ts.ClassElement,
  importedName: string,
  packageName: string,
  outputFilePath: string,
) {
  const jsDocCommentAndTags = ts.getJSDocCommentsAndTags(node);
  if (!jsDocCommentAndTags.length) return;

  const functionName = getFunctionName(node, importedName);

  const importStatement = ts.isClassElement(node)
    ? ((node.parent as ts.ClassDeclaration).name?.getText() ?? functionName)
    : importedName;

  const extendsClause = (() => {
    if (!ts.isClassElement(node) || !ts.isConstructorDeclaration(node))
      return "";

    const classDeclaration = node.parent as ts.ClassDeclaration;
    if (!classDeclaration.heritageClauses) return "";

    const extendsClause = classDeclaration.heritageClauses.find(
      (x) => x.token === ts.SyntaxKind.ExtendsKeyword,
    );
    if (!extendsClause) return "";

    const extendsType = extendsClause.types[0];
    return dedent`
    <Note>
    \`${importedName}\` extends \`${extendsType.expression.getText()}\`, see the docs for ${extendsType.expression.getText()} for all supported methods.
    </Note>
    `;
  })();

  const comment = jsDocCommentAndTags.find(
    (x) => x.kind === ts.SyntaxKind.JSDoc,
  ) as ts.JSDoc;

  const exampleTag = comment.tags?.find(
    (x) =>
      x.kind === ts.SyntaxKind.JSDocTag && x.tagName.escapedText === "example",
  );

  const parameterTags =
    (comment.tags?.filter(
      (x) => x.kind === ts.SyntaxKind.JSDocParameterTag,
    ) as ts.JSDocParameterTag[]) ?? [];
  const parameters = parameterTags.map((tag) => {
    const type = tag.typeExpression?.type;
    return {
      name: tag.name.getText(),
      type: type?.getText(),
      description: tag.comment,
    };
  });

  const parameterSection = parameters.length
    ? dedent`

    ## Parameters
    ${parameters
      .map(
        (param) => dedent`
    ### ${param.name}
    \`${param.type}\`
    ${param.description}
    `,
      )
      .join("\n\n")}
    \n
    `
    : "";

  const returnTag = comment.tags?.find(
    (x) => x.kind === ts.SyntaxKind.JSDocReturnTag,
  ) as ts.JSDocReturnTag | undefined;

  const returnSection = returnTag
    ? dedent`
    ## Returns
    \`${returnTag.typeExpression?.type?.getFullText()?.trim()}\`
    ${(returnTag && ts.getTextOfJSDocComment(returnTag?.comment)) ?? ""}
    `
    : "";

  const exampleSection = exampleTag
    ? dedent`
    ## Usage
    ${ts.getTextOfJSDocComment(exampleTag.comment)?.trim()}
    `
    : "";

  return dedent`
---
# This file is autogenerated
title: ${functionName}
description: Overview of the ${functionName} method
slug: ${getSlug(outputFilePath)}
---


${ts.getTextOfJSDocComment(comment?.comment)}
${extendsClause}

## Import
\`\`\`ts
import { ${importStatement} } from "${packageName}";
\`\`\`

${exampleSection}
${parameterSection}
${returnSection}
  `;
}
