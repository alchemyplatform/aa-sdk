<Info>
  The examples provided use [jq](https://jqlang.org/) to parse json and
  [foundry](https://getfoundry.sh/) to sign a raw payload.
</Info>

See the [`wallet_prepareCalls`](/docs/wallets/api/smart-wallets/wallet-api-endpoints/wallet-api-endpoints/wallet-prepare-calls),
[`wallet_sendPreparedCalls`](/docs/wallets/api/smart-wallets/wallet-api-endpoints/wallet-api-endpoints/wallet-send-prepared-calls),
and [`wallet_getCallsStatus`](/docs/wallets/api/smart-wallets/wallet-api-endpoints/wallet-api-endpoints/wallet-get-calls-status)
API reference for full descriptions of the parameters used in the following example.

<Steps>
    <Step title="Declare your secrets">
```bash twoslash maxLines=999
ALCHEMY_API_KEY=your-alchemy-api-key
CHAIN_ID=0x66eee # Your desired chain ID in hex
SIGNER_ADDRESS=your-signer-address
SIGNER_PRIVATE_KEY=your-signer-private-key
```
    </Step>

  <Step title="(If Needed) Request Account">
    If the user does not yet have a smart account, you must create one.
```bash twoslash maxLines=999
ACCOUNT_ADDRESS=$(curl --request POST \
  --url https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
  --header 'accept: application/json' \
  --data '
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "wallet_requestAccount",
  "params": [
    { 
      "signerAddress": "'$SIGNER_ADDRESS'"
    }
  ]
}
' | jq -r '.result.accountAddress')
```
  </Step>

  <Step title="Prepare Calls">
    First prepare the calls.

```bash twoslash maxLines=999
PREPARE_CALLS_RESPONSE=$(curl --request POST \
  --url https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
 --header 'accept: application/json' \
 --data '
{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "wallet_prepareCalls",
    "params": [
      {
        "calls": [
            {
                "to": "0x0000000000000000000000000000000000000000",
                "data": "0x",
                "value": "0x00"
            }
        ],
        "from": "'$ACCOUNT_ADDRESS'",
        "chainId": "'$CHAIN_ID'"
      }
    ]
}')
```

  </Step>

  <Step title="Sign the Prepared Calls">
    Sign the returned signature request. How you do this will vary depending on your environment.

```bash twoslash maxLines=999
# Extract values from prepare calls response
CALL_TYPE=$(echo $PREPARE_CALLS_RESPONSE | jq -r .result.type)
CALL_DATA=$(echo $PREPARE_CALLS_RESPONSE | jq -r .result.data)
SIGNATURE_PAYLOAD=$(echo $PREPARE_CALLS_RESPONSE | jq -r .result.signatureRequest.data.raw)
# Sign the payload with your private key
SIGNATURE=$(cast wallet sign --private-key "$SIGNER_PRIVATE_KEY" "$SIGNATURE_PAYLOAD")
```

  </Step>

<Step title="Send the Prepared Calls">
  Send the signed calls using `wallet_sendPreparedCalls`.
  
```bash twoslash maxLines=999
SEND_CALLS_RESPONSE=$(echo '{}' | jq -n \
  --arg call_type "$CALL_TYPE" \
  --argjson call_data "$CALL_DATA" \
  --arg chain_id "$CHAIN_ID" \
  --arg signature "$SIGNATURE" \
  '{
    "id": 1,
    "jsonrpc": "2.0", 
    "method": "wallet_sendPreparedCalls",
    "params": [{
      "type": $call_type,
      "data": $call_data,
      "chainId": $chain_id,
      "signature": {
        "type": "secp256k1",
        "data": $signature
      }
    }]
  }' | curl --request POST \
    --url https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
    --header 'accept: application/json' \
    --data @-)

CALL_ID=$(echo $SEND_CALLS_RESPONSE | jq -r '.result.preparedCallIds[0]')

````

</Step>

<Step title="Check the Calls Status">
  Finally check the calls status using `wallet_getCallsStatus`.

```bash twoslash maxLines=999
curl --request POST \
  --url https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
  --header 'accept: application/json' \
  --data '
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "wallet_getCallsStatus",
  "params": [
    "'$CALL_ID'"
  ]
}'
````

</Step>

</Steps>
