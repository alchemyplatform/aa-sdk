You will need to fill in values wrapped in curly braces like `{SIGNER_ADDRESS}`.

<Steps>

<Step title="(If needed) Request an account">

```bash
curl -X POST https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "wallet_requestAccount",
    "params": [
      {
        "signerAddress": "{SIGNER_ADDRESS}"
      }
    ]
  }'
```

This returns:

```bash
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "accountAddress": "ACCOUNT_ADDRESS",
    "id": "ACCOUNT_ID"
  }
}
```

For other potential responses, [check out the API reference!](https://www.alchemy.com/docs/wallets/api-reference/smart-wallets/wallet-api-endpoints/wallet-api-endpoints/wallet-request-account)

</Step>

<Step title="Prepare parallel calls">

To send additional parallel calls, we have to use the `nonceOverride` capability. This allows us to specify a `nonceKey` parameter, a hex value that fits inside a `uint152` and differentiates transactions.

In production, as long as the nonce key override is nonzero (zero is the default), and different between `prepareCalls` requests, the transactions will be processed in parallel.

In this example, you'll send the first request with the `0x01` nonce key override and the second with the `0x02` nonce key override.

```bash
curl --request POST \
  --url https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
  --header 'accept: application/json' \
  --data '
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "wallet_prepareCalls",
  "params": [
    {
      "calls": [
        {
          "to": "0x0000000000000000000000000000000000000000",
          "data": "0x"
        }
      ],
      "from": "{ACCOUNT_ADDRESS}",
      "chainId": "{CHAIN_ID}",
      "capabilities": {
        "paymasterService": {
          "policyId": "{PAYMASTER_POLICY_ID}"
        },
        "nonceOverride": {
          "nonceKey": "0x01"
        }
      }
    }
  ]
}'
```

```bash
curl --request POST \
  --url https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
  --header 'accept: application/json' \
  --data '
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "wallet_prepareCalls",
  "params": [
    {
      "calls": [
        {
          "to": "0x0000000000000000000000000000000000000000",
          "data": "0x"
        }
      ],
      "from": "{ACCOUNT_ADDRESS}",
      "chainId": "{CHAIN_ID}",
      "capabilities": {
        "paymasterService": {
          "policyId": "{PAYMASTER_POLICY_ID}"
        },
        "nonceOverride": {
          "nonceKey": "0x02"
        }
      }
    }
  ]
}'
```

Each of these requests return a result like so:

```bash
{
    "type": "user-operation-v070",
    "data": {...useropRequest},
    "chainId": "CHAIN_ID",
    "signatureRequest": {
        "type": "personal_sign",
        "data": {
            "raw": "HASH_TO_SIGN",
        },
        "rawPayload": "RAW_PAYLOAD_TO_SIGN"
    }
}
```

Note the two `signatureRequest` objects that were returned for each request! Also keep the returned `data` object from each request, you'll need them when we send the parallel transactions!

</Step>

<Step title="Sign the signature requests">
    To sign the signature requests, you should sign the `raw` fields (note, this is not a string! You need to pass it to your signer as raw bytes, generally like so: `{ raw: "0x..." }`) with your signer of choice.
    
    This should use the `personal_sign` RPC method, as noted by the `type` in the `signatureRequest`.
    
    Alternatively, you can sign the raw payloads with a simple `eth_sign` but this RPC method is not favored due to security concerns.
</Step>

<Step title="Send the prepared calls">

```bash
curl -X POST https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "wallet_sendPreparedCalls",
    "params": [
      {
        "type": "array",
        "data": [
          {
            "type": "user-operation-v070",
            "data": {DATA_ONE_FROM_STEP_2},
            "chainId": "{CHAIN_ID}",
            "signature": {
              "type": "secp256k1",
              "data": "{SIGNATURE_FROM_STEP_3}"
            }
          },
          {
            "type": "user-operation-v070",
            "data": {DATA_TWO_FROM_STEP_2},
            "chainId": "{CHAIN_ID}",
            "signature": {
              "type": "secp256k1",
              "data": "{SIGNATURE_FROM_STEP_3}"
            }
          }
        ]
      }
    ],
    "id": 1
  }'
```

This returns:

```bash
{
  "jsonrpc": "2.0",
  "id": "1",
  "result": {
    "preparedCallIds": [
      "PREPARED_CALL_ID_ONE",
      "PREPARED_CALL_ID_TWO"
    ]
  }
}
```

Note the two `PREPARED_CALL_ID`s! We'll use these to track call status in the next step.

For other potential responses, [check out the API reference!](https://www.alchemy.com/docs/wallets/api-reference/smart-wallets/wallet-api-endpoints/wallet-api-endpoints/wallet-send-prepared-calls)

</Step>

<Step title="Track the prepared calls">

You can use the `wallet_getCallsStatus` endpoint to check up on each transaction's status. This should be done once for each returned call id.

```bash
curl -X POST https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "wallet_getCallsStatus",
    "params": [
      [
        "{PREPARED_CALL_ID_ONE_OR_TWO_FROM_STEP_4}",
      ]
    ],
    "id": 1
  }'
```

This returns:

```bash
{
  "id": "1",
  "jsonrpc": "2.0",
  "result": {
    "id": "PREPARED_CALL_ID",
    "chainId": "CHAIN_ID",
    "atomic": true,
    "status": 200,
    "receipts": [...]
  }
}
```

Note that the status codes match the following:
| Code | Title |
|------|--------------------------|
| 100 | Pending |
| 200 | Confirmed |
| 400 | Offchain Failure |
| 500 | Onchain Failure |
| 600 | Partial Onchain Failure |

To get your transaction's mined transaction hash, you can access `result.receipts[0].transactionHash`.

For more details, check out [the API reference!](https://www.alchemy.com/docs/wallets/api-reference/smart-wallets/wallet-api-endpoints/wallet-api-endpoints/wallet-get-calls-status)

</Step>

</Steps>

<Accordion title="Full script example">

This is a full working bash script which sends parallel calls! You'll need the following env variables:

- ALCHEMY_API_KEY
- PRIVATE_KEY
- SIGNER_ADDRESS
- CHAIN_ID
- POLICY_ID

<Info>
  The examples provided use [foundry](https://getfoundry.sh/) and
  [jq](https://jqlang.org/) to prepare and parse
</Info>

```bash
#!/bin/bash

# Check required environment variables
if [[ -z "$ALCHEMY_API_KEY" || -z "$PRIVATE_KEY" || -z "$SIGNER_ADDRESS" || -z "$CHAIN_ID" || -z "$POLICY_ID" ]]; then
    echo "Error: Please set ALCHEMY_API_KEY, PRIVATE_KEY, SIGNER_ADDRESS, CHAIN_ID, and POLICY_ID environment variables"
    exit 1
fi

# Configuration
API_URL="https://api.g.alchemy.com/v2/$ALCHEMY_API_KEY"

echo "Starting parallel user operations flow..."

# Step 0: Request account address
echo "Requesting account address for signer: $SIGNER_ADDRESS"
ACCOUNT_RESPONSE=$(curl -s --request POST \
  --url "$API_URL" \
  --header 'accept: application/json' \
  --header 'content-type: application/json' \
  --data '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "wallet_requestAccount",
    "params": [
      {
        "signerAddress": "'"$SIGNER_ADDRESS"'"
      }
    ]
  }')

# Check for errors in account request
if [[ $(echo "$ACCOUNT_RESPONSE" | jq -r '.error') != "null" ]]; then
    echo "❌ Error in wallet_requestAccount: $(echo "$ACCOUNT_RESPONSE" | jq -r '.error.message')"
    exit 1
fi

# Extract account address
SENDER=$(echo "$ACCOUNT_RESPONSE" | jq -r '.result.accountAddress')
ACCOUNT_ID=$(echo "$ACCOUNT_RESPONSE" | jq -r '.result.id')

echo "Account Address: $SENDER"
echo "Account ID: $ACCOUNT_ID"

# Step 1: Prepare first call (nonce key 0x01)
echo "Preparing first call (nonce key 0x01)..."
PREPARE_RESPONSE_1=$(curl -s --request POST \
  --url "$API_URL" \
  --header 'accept: application/json' \
  --header 'content-type: application/json' \
  --data '{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "wallet_prepareCalls",
    "params": [
      {
        "calls": [
          {
            "to": "0x0000000000000000000000000000000000000000",
            "data": "0x"
          }
        ],
        "from": "'"$SENDER"'",
        "chainId": "'"$CHAIN_ID"'",
        "capabilities": {
          "paymasterService": {
            "policyId": "'"$POLICY_ID"'"
          },
          "nonceOverride": {
            "nonceKey": "0x01"
          }
        }
      }
    ]
  }')

# Step 2: Prepare second call (nonce key 0x02)
echo "Preparing second call (nonce key 0x02)..."
PREPARE_RESPONSE_2=$(curl -s --request POST \
  --url "$API_URL" \
  --header 'accept: application/json' \
  --header 'content-type: application/json' \
  --data '{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "wallet_prepareCalls",
    "params": [
      {
        "calls": [
          {
            "to": "0x0000000000000000000000000000000000000000",
            "data": "0x"
          }
        ],
        "from": "'"$SENDER"'",
        "chainId": "'"$CHAIN_ID"'",
        "capabilities": {
          "paymasterService": {
            "policyId": "'"$POLICY_ID"'"
          },
          "nonceOverride": {
            "nonceKey": "0x02"
          }
        }
      }
    ]
  }')

# Check for errors in responses
if [[ $(echo "$PREPARE_RESPONSE_1" | jq -r '.error') != "null" ]]; then
    echo "❌ Error in first prepareCalls: $(echo "$PREPARE_RESPONSE_1" | jq -r '.error.message')"
    exit 1
fi

if [[ $(echo "$PREPARE_RESPONSE_2" | jq -r '.error') != "null" ]]; then
    echo "❌ Error in second prepareCalls: $(echo "$PREPARE_RESPONSE_2" | jq -r '.error.message')"
    exit 1
fi

# Step 3: Extract raw hashes to sign
echo "Extracting signature hashes..."
RAW_HASH_1=$(echo "$PREPARE_RESPONSE_1" | jq -r '.result.signatureRequest.data.raw')
RAW_HASH_2=$(echo "$PREPARE_RESPONSE_2" | jq -r '.result.signatureRequest.data.raw')

echo "Raw hash 1: $RAW_HASH_1"
echo "Raw hash 2: $RAW_HASH_2"

# Step 4: Sign the hashes using cast
echo "Signing hashes with cast..."
SIGNATURE_1=$(cast wallet sign --private-key "$PRIVATE_KEY" "$RAW_HASH_1")
SIGNATURE_2=$(cast wallet sign --private-key "$PRIVATE_KEY" "$RAW_HASH_2")

echo "Signature 1: $SIGNATURE_1"
echo "Signature 2: $SIGNATURE_2"

# Step 5: Extract user operation data for sendPreparedCalls
echo "Extracting user operation data..."
USEROP_DATA_1=$(echo "$PREPARE_RESPONSE_1" | jq -c '.result.data')
USEROP_DATA_2=$(echo "$PREPARE_RESPONSE_2" | jq -c '.result.data')

# Step 6: Send prepared calls
echo "Sending prepared calls..."
SEND_RESPONSE=$(curl -s --request POST \
  --url "$API_URL" \
  --header 'accept: application/json' \
  --header 'content-type: application/json' \
  --data '{
    "jsonrpc": "2.0",
    "method": "wallet_sendPreparedCalls",
    "params": [
      {
        "type": "array",
        "data": [
          {
            "type": "user-operation-v070",
            "data": '"$USEROP_DATA_1"',
            "chainId": "'"$CHAIN_ID"'",
            "signature": {
              "type": "secp256k1",
              "data": "'"$SIGNATURE_1"'"
            }
          },
          {
            "type": "user-operation-v070",
            "data": '"$USEROP_DATA_2"',
            "chainId": "'"$CHAIN_ID"'",
            "signature": {
              "type": "secp256k1",
              "data": "'"$SIGNATURE_2"'"
            }
          }
        ]
      }
    ],
    "id": 1
  }')

# Step 7: Display results
echo "Results:"
echo "Send response:"
echo "$SEND_RESPONSE" | jq '.'

# Check for success
if [[ $(echo "$SEND_RESPONSE" | jq -r '.error') == "null" ]]; then
    echo "Success! Parallel user operations submitted."
    # Extract transaction hashes if available
    if [[ $(echo "$SEND_RESPONSE" | jq -r '.result') != "null" ]]; then
        echo "Result: $(echo "$SEND_RESPONSE" | jq -r '.result')"
    fi
else
    echo "Error in sendPreparedCalls: $(echo "$SEND_RESPONSE" | jq -r '.error.message')"
    exit 1
fi

```

</Accordion>
