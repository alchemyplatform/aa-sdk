---
title: Retry Transactions
description: Learn how to use drop and replace to retry failing transactions.
slug: wallets/transactions/retries
---

<Markdown src="../../shared/infra/drop-and-replace-description.mdx" />

<Tabs>
  <Tab title="React">
    Use the `useDropAndReplaceUserOperation()` hook to drop and replace. Retry a transaction by:

    1. Call `sendUserOperationAsync()` from `useSendUserOperation()` to send the initial transaction; it returns the pending hash
    2. Use the `useWaitForUserOperationTransaction()` hook to wait for the pending transaction
    3. If the transaction is stuck in the mempool, use the `useDropAndReplaceUserOperation()` hook to cancel the existing attempt and resubmit with an adjusted fee

    The example below implements this flow and wraps it in a retry helper with a configurable number of attempts.

    ```tsx twoslash
    import React from "react";
    import { View, Pressable, Text } from "react-native";
    import {
      useWaitForUserOperationTransaction,
      useDropAndReplaceUserOperation,
      useSendUserOperation,
      useSmartAccountClient,
    } from "@account-kit/react-native";

    // Configure how many drop-and-replace attempts to try if timeouts persist
    const MAX_REPLACEMENTS = 3;

    export function ComponentWithDropAndReplaceUO() {
      const { client } = useSmartAccountClient({});

      const { sendUserOperationAsync, isSendingUserOperation } =
        useSendUserOperation({
          client,
        });

      const {
        waitForUserOperationTransaction,
        isWaitingForUserOperationTransaction,
      } = useWaitForUserOperationTransaction({ client });

      const { dropAndReplaceUserOperation, isDroppingAndReplacingUserOperation } =
        useDropAndReplaceUserOperation({
          client,
          onSuccess: ({ hash, request }) => {
            // [optional] Do something with the hash and request
          },
          onError: (error) => {
            // [optional] Do something with the error
          },
        });

      function waitForUserOperationTransactionPromise(hash: `0x${string}`) {
        return new Promise<`0x${string}`>((resolve, reject) => {
          waitForUserOperationTransaction(
            { hash, retries: { maxRetries: 3, intervalMs: 5_000 } },
            { onSuccess: resolve, onError: reject },
          );
        });
      }

      // On failure retry and drop and replace, no backoff is required because a backoff is already
      // waited for in the waitForUserOperationTransaction function
      const waitUntilMinedWithRetries = async (params: {
        hash: `0x${string}`;
        request: any;
        maxReplacements: number;
      }): Promise<`0x${string}`> => {
        try {
          return await waitForUserOperationTransactionPromise(params.hash);
        } catch (e) {
          if (params.maxReplacements <= 0) throw e;
          const { hash: newHash } =
            await dropAndReplaceUserOperation({ uoToDrop: params.request });
          return waitUntilMinedWithRetries({
            hash: newHash as `0x${string}`,
            request: params.request,
            maxReplacements: params.maxReplacements - 1,
          });
        }
      };

      return (
        <View>
          <Pressable
            onPress={async () => {
              const { hash, request } = await sendUserOperationAsync({
                uo: {
                  target: "0xTARGET_ADDRESS",
                  data: "0x",
                  value: 0n,
                },
              });

              const minedTxHash = await waitUntilMinedWithRetries({
                hash,
                request,
                maxReplacements: MAX_REPLACEMENTS,
              });
              console.log("Mined transaction hash:", minedTxHash);
            }}
            disabled={
              isSendingUserOperation ||
              isDroppingAndReplacingUserOperation ||
              isWaitingForUserOperationTransaction
            }
          >
            <View>
              <Text>
                {isSendingUserOperation
                  ? "Sending..."
                  : isDroppingAndReplacingUserOperation
                    ? "Replacing..."
                    : "Send then Replace UO"}
              </Text>
            </View>
          </Pressable>
        </View>
      );
    }
    ```

  </Tab>
  <Tab title="JavaScript">
    <div>
      Use the `Smart Account Client` directly to send a transaction, wait for it, and replace it if it times out. The example below shows how
      to instantiate and initialize the `Smart Account Client`.

      <Markdown src="../../shared/infra/client.mdx" />

      Once initialized:
      1. Send the initial transaction with `sendUserOperation()`; it returns the pending hash
      2. Wait for the pending transaction with `waitForUserOperationTransaction({ hash })`
      3. If `waitForUserOperationTransaction({ hash })` errors, drop and replace with `dropAndReplaceUserOperation()`

      The example then wraps this flow in a retry helper with a configurable number of attempts.

      ```ts twoslash
      import { client } from "./client";

      const { hash, request } = await client.sendUserOperation({
        uo: {
          target: "0xTARGET_ADDRESS",
          data: "0x",
          value: 0n,
        },
      });

      // On failure retry and drop and replace, no backoff is required because a backoff is already
      // waited for in the waitForUserOperationTransaction function
      const waitUntilMinedWithRetries = async (params: {
        hash: `0x${string}`;
        request: any;
        maxReplacements: number;
      }): Promise<`0x${string}`> => {
        try {
          return await client.waitForUserOperationTransaction({
            hash: params.hash,
            retries: { maxRetries: 3, intervalMs: 5_000, multiplier: 1 },
          });
        } catch (e) {
          if (params.maxReplacements <= 0) throw e;
          const { hash: newHash } =
            await client.dropAndReplaceUserOperation({ uoToDrop: params.request });
          return waitUntilMinedWithRetries({
            hash: newHash as `0x${string}`,
            request: params.request,
            maxReplacements: params.maxReplacements - 1,
          });
        }
      };

      const minedTxHash = await waitUntilMinedWithRetries({
        hash,
        request,
        maxReplacements: 3,
      });
      console.log("Mined transaction hash:", minedTxHash);
      ```
    </div>

  </Tab>
</Tabs>
