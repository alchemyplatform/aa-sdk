---
title: Retry User Operations
description: Learn how to use Drop and Replace to retry failing user operations.
slug: wallets/transactions/retries
---

<Markdown src="../../shared/infra/drop-and-replace-description.mdx" />

<Tabs>
  <Tab title="React">
    Use the provided `useDropAndReplaceUserOperation()` hook to drop and replace. You can retry a user operation by:

    1. Calling `sendUserOperationAsync()` from `useSendUserOperation()` to send the initial user operation; it returns the pending user operation hash
    2. Using the `useWaitForUserOperationTransaction()` hook to wait for the pending user operation
    3. Using the `useDropAndReplaceUserOperation()` hook if the user operation is stuck in the mempool to cancel the existing operation and resubmit with an adjusted gas fee

    The example below implements this flow and wraps it in a retry helper with a configurable number of attempts.

    ```tsx twoslash
    import React from "react";
    import { View, Pressable, Text } from "react-native";
    import {
      useWaitForUserOperationTransaction,
      useDropAndReplaceUserOperation,
      useSendUserOperation,
      useSmartAccountClient,
    } from "@account-kit/react-native";

    // Configure how many drop-and-replace attempts to try if timeouts persist
    const MAX_REPLACEMENTS = 3;

    export function ComponentWithDropAndReplaceUO() {
      const { client } = useSmartAccountClient({});

      const { sendUserOperationAsync, isSendingUserOperation } =
        useSendUserOperation({
          client,
        });

      const {
        waitForUserOperationTransaction,
        isWaitingForUserOperationTransaction,
      } = useWaitForUserOperationTransaction({ client });

      const { dropAndReplaceUserOperation, isDroppingAndReplacingUserOperation } =
        useDropAndReplaceUserOperation({
          client,
          onSuccess: ({ hash, request }) => {
            // [optional] Do something with the hash and request
          },
          onError: (error) => {
            // [optional] Do something with the error
          },
        });

      function waitForUserOperationTransactionPromise(hash: `0x${string}`) {
        return new Promise<`0x${string}`>((resolve, reject) => {
          waitForUserOperationTransaction(
            { hash, retries: { maxRetries: 3, intervalMs: 5_000 } },
            { onSuccess: resolve, onError: reject },
          );
        });
      }

      // On failure retry and drop and replace, no backoff is required because a backoff is already
      // waited for in the waitForUserOperationTransaction function
      const waitUntilMinedWithRetries = async (params: {
        hash: `0x${string}`;
        request: any;
        maxReplacements: number;
      }): Promise<`0x${string}`> => {
        try {
          return await waitForUserOperationTransactionPromise(params.hash);
        } catch (e) {
          if (params.maxReplacements <= 0) throw e;
          const { hash: newHash } =
            await dropAndReplaceUserOperation({ uoToDrop: params.request });
          return waitUntilMinedWithRetries({
            hash: newHash as `0x${string}`,
            request: params.request,
            maxReplacements: params.maxReplacements - 1,
          });
        }
      };

      return (
        <View>
          <Pressable
            onPress={async () => {
              const { hash, request } = await sendUserOperationAsync({
                uo: {
                  target: "0xTARGET_ADDRESS",
                  data: "0x",
                  value: 0n,
                },
              });

              const minedTxHash = await waitUntilMinedWithRetries({
                hash,
                request,
                maxReplacements: MAX_REPLACEMENTS,
              });
              console.log("Mined transaction hash:", minedTxHash);
            }}
            disabled={
              isSendingUserOperation ||
              isDroppingAndReplacingUserOperation ||
              isWaitingForUserOperationTransaction
            }
          >
            <View>
              <Text>
                {isSendingUserOperation
                  ? "Sending..."
                  : isDroppingAndReplacingUserOperation
                    ? "Replacing..."
                    : "Send then Replace UO"}
              </Text>
            </View>
          </Pressable>
        </View>
      );
    }
    ```

  </Tab>
  <Tab title="JavaScript">
  
    We will be using the smart account client directly to send a user operation, wait for it, and replace it if it times out. Below is an example of how
    to instantiate and initialize the smart account client.

    <Markdown src="../../shared/infra/client.mdx" />

    Once initialized, you can:
    1. Send the initial user operation with `sendUserOperation()`; it returns the pending user operation hash
    2. Wait for the pending user operation with `waitForUserOperationTransaction({ hash })`
    3. If `waitForUserOperationTransaction({ hash })` errors, drop and replace with `dropAndReplaceUserOperation()`

    The example then wraps this flow in a retry helper with a configurable number of attempts.

    ```ts twoslash
    import { client } from "./client";

    const { hash, request } = await client.sendUserOperation({
      uo: {
        target: "0xTARGET_ADDRESS",
        data: "0x",
        value: 0n,
      },
    });

    // On failure retry and drop and replace, no backoff is required because a backoff is already
    // waited for in the waitForUserOperationTransaction function
    const waitUntilMinedWithRetries = async (params: {
      hash: `0x${string}`;
      request: any;
      maxReplacements: number;
    }): Promise<`0x${string}`> => {
      try {
        return await client.waitForUserOperationTransaction({
          hash: params.hash,
          retries: { maxRetries: 3, intervalMs: 5_000, multiplier: 1 },
        });
      } catch (e) {
        if (params.maxReplacements <= 0) throw e;
        const { hash: newHash } =
          await client.dropAndReplaceUserOperation({ uoToDrop: params.request });
        return waitUntilMinedWithRetries({
          hash: newHash as `0x${string}`,
          request: params.request,
          maxReplacements: params.maxReplacements - 1,
        });
      }
    };

    const minedTxHash = await waitUntilMinedWithRetries({
      hash,
      request,
      maxReplacements: 3,
    });
    console.log("Mined transaction hash:", minedTxHash);
    ```

  </Tab>
</Tabs>
