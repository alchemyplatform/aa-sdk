---
title: Server-side Rendering
description: Learn how to use Smart Wallets with server-side rendering.
slug: wallets/troubleshooting/ssr
---

> ⚠️ **Common Issue**: If SSR is not set up correctly, you may see sessions resetting or users getting logged out unexpectedly. Make sure to follow this guide fully to preserve session state.

When using Smart Wallets in a server-side rendered setting, you will see inconsistencies of the user state between the server and the client. This will lead to flashes of content when a user is logged in. To avoid this, the account state can be optimistically loaded on the server and passed to the client.

## Update your config

To enable server-side rendering support, you need to set `ssr: true` when creating a config.

<Tabs>
  <Tab title="React">

When using React, you should also make the config a function so that you can call it once per request, which allows for request-based isolation of the account state.

```ts twoslash config.ts
import { createConfig } from "@account-kit/react";
import { sepolia, alchemy } from "@account-kit/infra";

export const config = () =>
  createConfig({
    // required
    transport: alchemy({ rpcUrl: "/api/rpc" }),
    chain: sepolia,
    ssr: true, // [!code ++]
  });
```

This setting will defer hydration of the account state to the client after the initial mount.

## Persisting the Account State

### Cookie Storage

To consistently pass the state between the server and the client, you can pass in a cookie storage to the `config` object created above. The cookie storage allows the client state to be written serialized to a cookie which can be passed along to the server on each request. This allows the server to have access to certain parts of the account state when rendering, ensuring a consistent render between client and server (eg. user's address displayed in the top nav). Instances which can only be created on the client will still not be available on the server, however. This includes the signer or smart contract account instances.

```ts twoslash config.ts
import {
  createConfig,
  cookieStorage, // [!code ++]
} from "@account-kit/react";
import { sepolia, alchemy } from "@account-kit/infra";
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient();

// [!code focus:99]
export const config = () =>
  createConfig({
    // required
    transport: alchemy({ rpcUrl: "/api/rpc" }),
    chain: sepolia,
    ssr: true, // [!code ++]
    storage: cookieStorage, // [!code ++]
  });
```

Now, depending on your application, you can get the state from cookies and pass in the `initialState` to the `AlchemyAccountProvider` to hydrate the account state on the client.

### Next.js App Directory

If you are using NextJS App Directory, you can read the cookie state and pass it to the providers like so:

<CodeBlocks>

```tsx twoslash layout.tsx filename=layout.tsx
// @noErrors
import React from "react";
import { cookieToInitialState } from "@account-kit/core";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { headers } from "next/headers";
import { config } from "./config";
import "./globals.css";
import { Providers } from "./providers";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Embedded Accounts Getting Started",
  description: "Embedded Accounts Quickstart Guide",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // This will allow us to persist state across page boundaries
  const initialState = cookieToInitialState(
    // the config here is just used to compute the initial state
    config(),
    headers().get("cookie") ?? undefined,
  );

  return (
    <html lang="en">
      <body className={inter.className}>
        <Providers initialState={initialState}>{children}</Providers>
      </body>
    </html>
  );
}
```

```tsx twoslash providers.tsx filename=providers.tsx
// @noErrors
"use client";

import React, { useRef } from "react";
import { AlchemyClientState } from "@account-kit/core";
import {
  AlchemyAccountProvider,
  type AlchemyAccountsConfigWithUI,
} from "@account-kit/react";
import { QueryClientProvider } from "@tanstack/react-query";
import { PropsWithChildren, Suspense } from "react";
import { config, queryClient } from "./config";

export const Providers = (
  props: PropsWithChildren<{ initialState?: AlchemyClientState }>,
) => {
  const ref = useRef<AlchemyAccountsConfigWithUI>();
  if (!ref.current) {
    ref.current = config();
  }

  return (
    <Suspense>
      <QueryClientProvider client={queryClient}>
        <AlchemyAccountProvider
          config={ref.current!}
          queryClient={queryClient}
          initialState={props.initialState}
        >
          {props.children}
        </AlchemyAccountProvider>
      </QueryClientProvider>
    </Suspense>
  );
};
```

```tsx twoslash config.ts filename=config.ts
import { createConfig, cookieStorage } from "@account-kit/react";
import { sepolia, alchemy } from "@account-kit/infra";
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient();

// When using SSR, you need to be able to create a config per request
// This is to avoid sharing state between requests (eg. signed in users)
export const config = () =>
  createConfig({
    transport: alchemy({ rpcUrl: "/api/rpc" }),
    chain: sepolia,
    ssr: true,
    storage: cookieStorage,
  });
```

</CodeBlocks>

  </Tab>
  <Tab title="Other Javascript">

```ts twoslash
import { createConfig } from "@account-kit/core";
import { sepolia, alchemy } from "@account-kit/infra";

export const config = createConfig({
  transport: alchemy({ apiKey: "ALCHEMY_API_KEY" }),
  chain: sepolia,
  ssr: true, // [!code ++]
});
```

This setting will defer hydration of the account kit state until you can call the `hydrate` method on mount.

## Hydrate the Account State

Now that you've set up your config for SSR, you will have to manually hydrate the state on the client. This can be done by calling the `hydrate` method exported by Smart Wallets core.

<CodeBlocks>

```ts twoslash hydrate.ts
import { hydrate } from "@account-kit/core";
import { config } from "./config";

const { onMount } = hydrate(config);

// when your component has mounted on the client, call the onMount method
// how you do this will depend on your framework, but here we'll just check for `window`
// to be defined
if (typeof window !== "undefined") {
  onMount();
}
```

```ts twoslash config.ts filename="config.ts"
import { createConfig } from "@account-kit/core";
import { alchemy, sepolia } from "@account-kit/infra";

export const config = createConfig({
  transport: alchemy({ apiKey: "YOUR_API_KEY" }),
  chain: sepolia,
  ssr: true,
});
```

</CodeBlocks>

## Persisting the Account State

To consistently pass the state between the server and the client, you can pass in a cookie storage to the `config` object created above. The cookie storage allows the client state to be written serialized to a cookie which can be passed along to the server on each request. This allows the server to have access to certain parts of the account state when rendering, ensuring a consistent render between client and server (eg. user's address displayed in the top nav). Instances which can only be created on the client will still not be available on the server, however. This includes the signer or smart contract account instances.

```ts twoslash
import {
  createConfig,
  cookieStorage, // [!code ++]
} from "@account-kit/core";
import { sepolia, alchemy } from "@account-kit/infra";

export const config = createConfig({
  transport: alchemy({ apiKey: "ALCHEMY_API_KEY" }),
  chain: sepolia,
  ssr: true, // [!code ++]
  storage: cookieStorage, // [!code ++]
});
```

Now you can get the initial state from cookies and pass it to the `hydrate` method to hydrate the account state on the client or on the server.

<CodeBlocks>

```ts twoslash hydrate.ts
import { cookieToInitialState, hydrate } from "@account-kit/core";
import { config } from "./config";

// this is an example of how to get the cookie on the client
// but on the server you might get it from the `req.cookies` object
// it all depends on your framework
const initialState = cookieToInitialState(config, document.cookie); // [!code ++]
const { onMount } = hydrate(config, initialState);

if (typeof window !== "undefined") {
  onMount();
}
```

```ts twoslash config.ts filename="config.ts"
import { createConfig, cookieStorage } from "@account-kit/core";
import { sepolia, alchemy } from "@account-kit/infra";

export const config = createConfig({
  transport: alchemy({ apiKey: "ALCHEMY_API_KEY" }),
  chain: sepolia,
  ssr: true,
  storage: cookieStorage,
});
```

</CodeBlocks>

  </Tab>
</Tabs>
