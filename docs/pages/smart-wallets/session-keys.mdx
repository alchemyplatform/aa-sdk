---
title: Session Keys
subtitle: Learn how to use session keys with Wallet APIs
url: https://docs.alchemy.com/reference/wallet-apis-session-keys
slug: reference/wallet-apis-session-keys
---

Session keys are a powerful feature of the Alchemy Wallets API that allow you to create a session for a user's smart account with specific permissions. This enables secure, permissioned access to the user's wallet, allowing your app's server to perform actions on behalf of the user without needing their private key.

### Create A Session With Permissions

Session keys allow another account to operate on a user's smart account with given permissions. After creating a session, you will be able to sign transactions for the generated wallet within the defined permissions using that session key. See [here for a list of permissions!](#permission-types)

This guide assumes you have an account you can sign with, like an [Alchemy Signer](https://www.alchemy.com/docs/wallets/signer/what-is-a-signer#alchemy-signer) or a user's EOA. You will also need an Alchemy API key, and a [gas manager policy ID](https://www.alchemy.com/docs/wallets/react/sponsor-gas) if you want to sponsor gas.

<Tip title="Don't have an API key?" icon="star">
  Start using the Alchemy Wallets API today! [Get started for
  free](https://dashboard.alchemy.com/signup/?a=f8afc2202c).
</Tip>

We'll demonstrate how to create and use session keys [using the SDK client](#using-the-typescript-sdk) or by using platform-agnostic [JSON-RPC APIs](#using-the-json-rpc-apis-directly).

<Tabs>
  <Tab title="Using The TypeScript SDK">
    ## Using The TypeScript SDK

    ### 1. Install Prerequisites

    You're going to need the `@account-kit/wallet-client` and `@account-kit/infra`. We'll also be using `LocalAccountSigner` from `@aa-sdk/core` as the signer for demonstration purposes.

    <CodeGroup>
    ```shell npm
    npm install @account-kit/wallet-client @account-kit/infra @aa-sdk/core
    ```

    ```shell bun
    bun add @account-kit/wallet-client @account-kit/infra @aa-sdk/core
    ```

    ```shell yarn
    yarn add @account-kit/wallet-client @account-kit/infra @aa-sdk/core
    ```

    ```shell pnpm
    pnpm install @account-kit/wallet-client @account-kit/infra @aa-sdk/core
    ```

    </CodeGroup>

    ### 2. Create A Smart Wallet Client

    Create a client for a given signer (e.g. a `LocalAccountSigner` imported from `@aa-sdk/core` or an [Alchemy Signer](https://www.alchemy.com/docs/wallets/signer/what-is-a-signer#alchemy-signer)).

    ```ts
    import { createSmartWalletClient } from "@account-kit/wallet-client";
    import { alchemy, arbitrumSepolia } from "@account-kit/infra";
    import { LocalAccountSigner } from "@aa-sdk/core";

    const signer = LocalAccountSigner.privateKeyToAccountSigner(PRIVATE_KEY); // we use a private key signer as an example here

    const transport = alchemy({
      apiKey: ALCHEMY_API_KEY, // use your Alchemy app api key here
    });

    const client = createSmartWalletClient({
      transport,
      chain: arbitrumSepolia, // use any chain imported from @account-kit/infra here
      signer,
    });
    ```

    ### 3. Create the session key

    <Accordion title="Using EIP-7702?">

    If you are using an EIP-7702 account, the account must be delegated onchain
    before creating the sesion. If the account has already sent calls, it will
    already be delegated. If it hasn't sent any calls before creating the session
    key, you can delegate it by sending an empty call as the owner:

    ```ts
    const preparedCalls = await client.prepareCalls({
      calls: [], // empty array since you don't want to send any calls
      from: account.address,
      capabilities: {
        paymasterService: {
          policyId: GAS_MANAGER_POLICY_ID, // put your gas manager policy ID here
        },
      },
    });

    const signedCalls = await client.signPreparedCalls(preparedCalls);

    const { preparedCallIds } = await client.sendPreparedCalls(signedCalls);

    const status = await client.getCallsStatus(preparedCallIds[0]);
    ```

    Now you can continue to create the session key as described below.

    </Accordion>

    ```ts
    const account = await client.requestAccount(); // Request an account for the owner signer

    // This is where you would use your session key signer!
    const sessionKey = LocalAccountSigner.generatePrivateKeySigner();

    const permissions = await client.grantPermissions({
      account: account.address,
      expirySec: Math.floor(Date.now() / 1000) + 60 * 60,
      key: {
        publicKey: await sessionKey.getAddress(),
        type: "secp256k1",
      },
      permissions: [{ type: "root" }], // Here we grant root permissions as an example, but this is not advised in production!
    });
    ```

    ### 4. Send calls using the session key

    ```ts
    import { signPreparedCalls } from "@account-kit/wallet-client";

    const preparedCalls = await client.prepareCalls({
      calls: [{ to: "0x0000000000000000000000000000000000000000", value: "0x0" }],
      from: account.address,
      capabilities: {
        paymasterService: {
          policyId: GAS_MANAGER_POLICY_ID, // put your gas manager policy ID here
        },
        permissions,
      },
    });

    const signedCalls = await signPreparedCalls(
      sessionKey, // Note that we now sign with the session key!
      preparedCalls,
    );

    const { preparedCallIds } = await client.sendPreparedCalls({
      ...signedCalls,
      capabilities: {
        permissions,
      },
    });

    // Check calls status.
    const status = await client.getCallsStatus(preparedCallIds[0]);
    ```

  </Tab>
  <Tab title="Using The JSON-RPC APIs Directly">
    ## Using The JSON-RPC APIs Directly

    ### 1. Request an Account for the Owner Signer

    Given an owner address, call `wallet_requestAccount` to return the smart account address for that owner. The [owner](https://accountkit.alchemy.com/concepts/smart-account-signer) address can be any signer (or public key) that has the ability to sign transactions.

    - If you want to use social sign up / log in, you can simply use the [SDK](https://accountkit.alchemy.com/react/getting-started) to authenticate users and retrieve their signer address
    - If instead, you want to generate and control wallets with a custodied owner, you can generate any public private key pair (e.g. any EOA)

    This will return the account address associated with the given signer, as well as a uuid you could use to differentiate between accounts for the same signer in the future.

    ```bash
    curl --request POST \
        --url https://api.g.alchemy.com/v2/API_KEY \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '
    {
      "id": 1,
      "jsonrpc": "2.0",
      "method": "wallet_requestAccount",
      "params": [
        {
          "signerAddress": "0xOWNER_ADDRESS"
        }
      ]
    }
    '
    ```

    This will return the smart account address associated with the given signer:

    ```bash
    {
      "jsonrpc": "2.0",
      "id": 1,
      "result": {
        "accountAddress": "0xACCOUNT_ADDRESS",
        "id": "af638-a8..."
      }
    }
    ```

    ### 2. Create a Session With the Session Key Signer

    <Accordion title="Using EIP-7702?">

    If you are using an EIP-7702 account, the account must be delegated onchain
    before creating the sesion. If the account has already sent calls, it will
    already be delegated. If it hasn't sent any calls before creating the session
    key, you can delegate it by sending an empty call as the owner.

    [Follow the instructions here](/docs/reference/wallet-apis-7702-quickstart#using-the-json-rpc-apis-directly)
    to send your first call. Note that the `calls` in the request to `wallet_prepareCalls` can be an empty array
    if you do not want to send any calls.

    </Accordion>

    To create a session key using onchain policies:

    - Get the public address of a key you want to use as a session key. This can be any key pair that has the ability to sign (aka a [signer](https://accountkit.alchemy.com/concepts/smart-account-signer) that is either an local [signer](https://accountkit.alchemy.com/reference/aa-sdk/core/classes/LocalAccountSigner/constructor#localaccountsigner) like an EOA or signer generated with a signer provider).
    - Create a session for that key its public address, by passing it as the `publicKey` in a call to `wallet_createSession`.

    Note that the expiry is in seconds and represents a UNIX timestamp (e.g. 1776657600 for April 20th, 2077).

    ```bash
    curl --request POST \
        --url https://api.g.alchemy.com/v2/API_KEY \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '
    {
      "jsonrpc": "2.0",
      "id": 1,
      "method": "wallet_createSession",
      "params": [
        {
          "account": "0xACCOUNT_ADDRESS",
          "chainId": "0xCHAIN_ID",
          "expirySec": UNIX_TIMESTAMP_EXPIRY_IN_SECONDS,
          "key": {
            "publicKey": "0xSESSION_KEY_ADDRESS",
            "type": "secp256k1"
          },
          "permissions": [
            {
              "type": "root"
            }
          ]
        }
      ]
    }'
    ```

    This will return two key elements:

    1. The session ID
    2. The signature request that must be signed by the account owner to authorize the session key

    Keep note of the session ID, you'll need it later!

    ```bash
    {
        "jsonrpc": "2.0",
        "id": 1,
        "result": {
            "sessionId": "0xSESSION_ID",
            "signatureRequest": {
                "type": "eth_signTypedData_v4",
                "data": {...}
            }
        }
    }
    ```

    ### 3. Sign the Session Key Authorization

    Sign the signature request using the account owner's key (used in step 1), then store the resulting signature.

    ### 4. Prepare Calls With the Session Key

    With the session ID received in step 2 and the signature from step 3, we're now ready to prepare some calls!

    ```bash
    curl --request POST \
        --url https://api.g.alchemy.com/v2/API_KEY \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '
    {
      "id": 1,
      "jsonrpc": "2.0",
      "method": "wallet_prepareCalls",
      "params": [
        {
          "capabilities": {
            "paymasterService": {
                "policyId": GAS_MANAGER_POLICY_ID, // put your gas manager policy ID here
            },
            "permissions": {
              "sessionId": 0xSESSION_ID,
              "signature": 0xPERMISSION_SIG,
            }
          },
          "calls": [
            {
              "to": "0x0000000000000000000000000000000000000000"
            }
          ],
          "from": "0xACCOUNT_ADDRESS",
          "chainId": "0xCHAIN_ID"
        }
      ]
    }
    '
    ```

    This will return the userop request (the `data` field) and a signature request, for example:

    ```bash
    type: "user-operation-v070",
    data: {...useropRequest},
    chainId: "0xCHAIN_ID"
    signatureRequest: {
      type: "personal_sign",
      data: {
        raw: HASH_TO_SIGN,
      }
    }
    ```

    ### 5. Sign the userop

    With the returned signature request, all you have to do is sign the userop hash returned in the `signatureRequest.data` field. You can sign this with the session key. This signature will be valid as long as it is within the permissions the session key has.

    Note that the `type` field in the `signatureRequest` indicates the signature type needed, in this case, we need to `personal_sign` the hash.

    ### 6. Send the Prepared Calls!

    With the signature from step 5 and the `useropRequest` from step 4, you're good to go to send the call!

    ```bash
    curl --request POST \
        --url https://api.g.alchemy.com/v2/API_KEY \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '
    {
      "id": 1,
      "jsonrpc": "2.0",
      "method": "wallet_sendPreparedCalls",
      "params": [
        {
          "type": "user-operation-v070",
          "data": {...useropRequest},
          "chainId": "0xCHAIN_ID", // e.g. "0x66eee" for Arbitrum Sepolia
          "capabilities": {
            "permissions": {
              "sessionId": 0xSESSION_ID,
              "signature": 0xPERMISSION_SIG,
            }
          },
          "signature": {
            "type": "secp256k1",
            "data": "0xUSEROP_SIGNATURE",
          }
        }
      ]
    }
    '
    ```

    This will return the array of prepared call IDs!

    ## Permission Types

    To specify permissions during a session key installation, include them in the `permissions` array when calling `client.grantPermission()` via the SDK or `wallet_createSession` via the API.

    ```ts
    const permissions = await client.grantPermissions({
      account: account.address,
      expirySec: Math.floor(Date.now() / 1000) + 60 * 60,
      key: {
        publicKey: await sessionKey.getAddress(),
        type: "secp256k1",
      },
      permissions: [{ PERMISSION_ONE }, { PERMISSION_TWO }],
    });
    ```

    ### Native Token Transfer

    This permission allows transfer of native tokens (like Ether) from the account.

    ```ts
    {
      type: "native-token-transfer";
      data: {
        allowance: Hex; // a hexadecimal encoded transfer limit, for example, 1 ETH would be 0xde0b6b3a7640000 (1e18 in hex)
      }
    }
    ```

    ### ERC20 Token Transfer

    This permission allows transfer or approval of erc20 tokens from the account. Both transfers and approvals count towards the limit.

    ```ts
    {
      type: "erc20-token-transfer";
      data: {
        address: Address; // erc20 token contract address
        allowance: Hex; // a hexadecimal encoded transfer limit
      }
    }
    ```

    ### Gas Limit

    This permission allows the session key to spend gas for user operations up to a specified limit.

    ```ts
    {
      type: "gas-limit";
      data: {
        limit: Hex; // a hexadecimal encoded gas limit, for example 300000 gas would be 0x493e0
      }
    }
    ```

    ### Contract Access

    This permission grants access to **all** functions in a specific contract.

    ```ts
    {
      type: "contract-access";
      data: {
        address: Address; // the target contract’s address
      }
    }
    ```

    ### Account Functions

    This permission grants access to specific functions on the smart account itself.

    ```ts
    {
      type: "account-functions";
      data: {
        functions: Hex[]; // array of allowed function selectors, e.g. ["0xabcdef01", "0x12345678"]
      };
    }
    ```

    ### Functions On All Contracts

    This permission grants access to a set of function selectors **across any** address.

    ```ts
    {
      type: "functions-on-all-contracts";
      data: {
        functions: Hex[]; // array of function selectors allowed globally, e.g. ["0xddf252ad"]
      };
    }
    ```

    ### Functions On Contract

    This permission grants access to specific function selectors on **one** contract.

    ```ts
    {
      type: "functions-on-contract";
      data: {
        address: Address;  // the contract address you’re targeting
        functions: Hex[];  // array of allowed function selectors for that contract, e.g. ["0xddf252ad"]
      };
    }
    ```

    ### Root

    This permission grants full access to everything. Needless to say, this is a very dangerous permission to grant.

    ```ts
    {
      type: "root"; // no additional data required
    }
    ```

  </Tab>
</Tabs>
