import { type Plugin } from "@wagmi/cli";
import { pascalCase } from "change-case";
import dedent from "dedent";
import {
  createPublicClient,
  getAbiItem,
  getContract,
  http,
  type AbiItem,
} from "viem";
import { localhost } from "viem/chains";
import { IPluginAbi } from "../src/msca/abis/IPlugin.js";

type RequiredBy<TType, TKeys extends keyof TType> = Required<
  Pick<TType, TKeys>
> &
  Omit<TType, TKeys>;

export function plugingen(): RequiredBy<Plugin, "run"> {
  return {
    name: "ERC6900PluginGen: This file is auto-generated by plugingen",
    run: async ({ contracts }) => {
      if (contracts.length > 1) {
        console.warn(
          "[WARN] plugingen should be used with ArrayConfig in wagmi config"
        );
      }

      // TODO: move this out of here and have the plugin accept the connection params for where
      // to pull this data from
      const client = createPublicClient({
        chain: localhost,
        transport: http(),
      });

      const content: string[] = [];
      for (const contract of contracts) {
        // This is done to clear out the ABI generated by wagmi
        contract.content = "";

        if (contract.address == null || typeof contract.address !== "string") {
          throw new Error("contract must have an address and only one address");
        }

        const plugin = getContract({
          address: contract.address,
          abi: IPluginAbi,
          publicClient: client,
        });

        const { executionFunctions } = await plugin.read.pluginManifest();
        const { name, version } = await plugin.read.pluginMetadata();

        const executionAbi = executionFunctions.map((f) => {
          const item = getAbiItem({
            abi: contract.abi,
            name: f,
          }) as AbiItem;

          if (item.type !== "function") {
            throw new Error(
              "execution function not mapping to a function in the ABI",
              { cause: JSON.stringify(item, null, 2) }
            );
          }

          return item;
        });

        const executionAbiConst = `${contract.name}ExecutionFunctionAbi`;

        const encodeFunctions = executionAbi.map((n) => {
          const argsParamString =
            n.inputs.length > 0
              ? `{ args }: GetFunctionArgs<typeof ${executionAbiConst}, "${n.name}">`
              : "";
          const argsEncodeString = n.inputs.length > 0 ? "args," : "";
          return dedent`
                encode${pascalCase(n.name)}Data: (${argsParamString}) => {
                    return encodeFunctionData({
                        abi: ${executionAbiConst},
                        functionName: "${n.name}",
                        ${argsEncodeString}
                    })
                }
            `;
        });

        content.push(dedent`
            const ${contract.name}_ = {
                meta: {
                    name: "${name}",
                    version: "${version}",
                },
                decorators: { ${encodeFunctions.join(",\n\n")} }
            }

            export const ${contract.name}: Plugin<typeof ${
          contract.name
        }_["decorators"]> = ${contract.name}_;
        `);

        // add the abi at the end so it's easier to read the actual plugin code output
        content.push(dedent`
            export const ${executionAbiConst} = ${JSON.stringify(
          executionAbi
        )} as const;
        `);
      }

      const imports = dedent`
        import { type GetFunctionArgs, encodeFunctionData } from "viem";
        import type { Plugin } from "./types";
      `;

      return {
        imports,
        content: content.join("\n\n"),
      };
    },
  };
}
