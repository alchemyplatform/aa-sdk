import type { ConnectionConfig, RequiredBy } from "@alchemy/aa-core";
import { type Plugin } from "@wagmi/cli";
import { camelCase, pascalCase } from "change-case";
import dedent from "dedent";
import {
  createPublicClient,
  getAbiItem,
  getContract,
  http,
  type AbiItem,
  type Chain,
} from "viem";
import { IPluginAbi } from "../src/msca/abis/IPlugin.js";

export function plugingen({
  chain,
  connectionConfig,
}: {
  chain: Chain;
  connectionConfig: ConnectionConfig;
}): RequiredBy<Plugin, "run"> {
  return {
    name: "ERC6900PluginGen: This file is auto-generated by plugingen",
    run: async ({ contracts }) => {
      if (contracts.length > 1) {
        console.warn(
          "[WARN] plugingen should be used with ArrayConfig in wagmi config"
        );
      }

      const rpcUrl =
        connectionConfig.rpcUrl == null
          ? `${chain.rpcUrls.alchemy.http[0]}/${
              connectionConfig.apiKey ?? process.env.API_KEY
            }`
          : connectionConfig.rpcUrl;

      const client = createPublicClient({
        chain,
        transport: http(rpcUrl, {
          fetchOptions: {
            headers: {
              Authorization: `Bearer ${connectionConfig.jwt}`,
            },
          },
        }),
      });

      const content: string[] = [];
      for (const contract of contracts) {
        // This is done to clear out the ABI generated by wagmi
        contract.content = "";

        if (contract.address == null) {
          throw new Error("contract must have at least one address");
        }

        const address =
          typeof contract.address === "string"
            ? { [chain.id]: contract.address }
            : contract.address;

        if (!(chain.id in address)) {
          throw new Error(
            `contract address missing for the reference chain ${chain.id}`
          );
        }

        const plugin = getContract({
          address: address[chain.id],
          abi: IPluginAbi,
          publicClient: client,
        });

        const { executionFunctions } = await plugin.read.pluginManifest();
        const { name, version } = await plugin.read.pluginMetadata();

        const executionAbi = executionFunctions.map((f) => {
          const item = getAbiItem({
            abi: contract.abi,
            name: f,
          }) as AbiItem;

          if (item.type !== "function") {
            throw new Error(
              "execution function not mapping to a function in the ABI",
              { cause: JSON.stringify(item, null, 2) }
            );
          }

          return item;
        });

        const executionAbiConst = `${contract.name}ExecutionFunctionAbi`;

        const accountFunctions = executionAbi.map((n) => {
          const methodContent = [];
          const argsParamString =
            n.inputs.length > 0
              ? `{ args }: GetFunctionArgs<typeof ${executionAbiConst}, "${n.name}">`
              : "";
          const argsEncodeString = n.inputs.length > 0 ? "args," : "";
          const isViewFunction = n.stateMutability === "view";

          methodContent.push(dedent`
            encode${pascalCase(n.name)}Data: (${argsParamString}) => {
                return encodeFunctionData({
                    abi: ${executionAbiConst},
                    functionName: "${n.name}",
                    ${argsEncodeString}
                });
            }
          `);

          if (isViewFunction) {
            methodContent.push(dedent`
              read${pascalCase(n.name)}: async (${argsParamString}) => {
                return account.rpcProvider.readContract({
                  address: await account.getAddress(),
                  abi: ${executionAbiConst},
                  functionName: "${n.name}",
                  ${argsEncodeString}
                });
              }
            `);
          }

          return methodContent.join(",\n\n");
        });

        const providerFunctions = executionAbi
          .filter((n) => n.stateMutability !== "view")
          .map((n) => {
            const argsParamString =
              n.inputs.length > 0
                ? `{ args }: GetFunctionArgs<typeof ${executionAbiConst}, "${n.name}">`
                : "";
            const argsEncodeString = n.inputs.length > 0 ? "args," : "";

            return dedent`
            ${camelCase(n.name)}: (${argsParamString}) => {
              const callData = encodeFunctionData({
                abi: ${executionAbiConst},
                functionName: "${n.name}",
                ${argsEncodeString}
              });

              return provider.sendUserOperation(callData);
            }
          `;
          });

        content.push(dedent`
            const ${contract.name}_ = {
                meta: {
                    name: "${name}",
                    version: "${version}",
                    addresses: {${Object.entries(address).reduce(
                      (prev, [chainId, addr]) =>
                        (prev += `${chainId}: "${addr}" as Address, `),
                      ""
                    )}},
                },
                accountMethods: (account: IMSCA<any, any>) => ({ ${accountFunctions.join(
                  ",\n\n"
                )} }),
                providerMethods: <
                  TTransport extends SupportedTransports,
                  P extends ISmartAccountProvider<TTransport> & { account: IMSCA<TTransport> }
                >(
                  provider: P
                ) => ({ ${providerFunctions.join(",\n\n")} }),
            }

            export const ${contract.name}: Plugin<ReturnType<typeof ${
          contract.name
        }_["accountMethods"]>, ReturnType<typeof ${
          contract.name
        }_["providerMethods"]>> = ${contract.name}_;
        `);

        // add the abi at the end so it's easier to read the actual plugin code output
        content.push(dedent`
            export const ${executionAbiConst} = ${JSON.stringify(
          executionAbi
        )} as const;
        `);
      }

      const imports = dedent`
        import { type Address, type GetFunctionArgs, encodeFunctionData } from "viem";
        import type { Plugin } from "./types";
        import type { IMSCA } from "../builder";
        import type { ISmartAccountProvider, SupportedTransports } from "@alchemy/aa-core";
      `;

      return {
        imports,
        content: content.join("\n\n"),
      };
    },
  };
}
